#!/usr/bin/env python3
"""
InfraDoc 2.0 - Documentation Generator
Generates comprehensive infrastructure documentation from analysis results.
"""

import json
import logging
from pathlib import Path
from typing import Dict, List, Any
from dataclasses import asdict
from datetime import datetime

# Configure logging with Windows-safe format (no emojis)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class DocumentationGenerator:
    """Generate comprehensive documentation from infrastructure analysis."""
    
    def __init__(self, scan_report, output_dir: str):
        """Initialize documentation generator."""
        self.scan_report = scan_report
        self.output_dir = Path(output_dir)
        self.docs_dir = self.output_dir / "documentation"
        self.docs_dir.mkdir(parents=True, exist_ok=True)
        
        logger.info(f"[DOCS] Documentation generator initialized: {self.docs_dir}")
    
    def generate_all_documentation(self) -> bool:
        """Generate all documentation files."""
        try:
            logger.info("[DOCS] Generating comprehensive documentation suite")
            
            self._generate_executive_summary()
            self._generate_technical_documentation()
            self._generate_developer_guide()
            self._generate_security_report()
            self._generate_architecture_documentation()
            self._generate_mermaid_diagrams()
            self._generate_documentation_index()
            
            logger.info("[DOCS] All documentation generated successfully")
            return True
            
        except Exception as e:
            logger.error(f"[DOCS] Documentation generation failed: {e}")
            return False
    
    def _generate_executive_summary(self):
        """Generate executive summary."""
        logger.info("[DOCS] Generating executive summary")
        
        insights = self.scan_report.infrastructure_insights
        security = self.scan_report.security_analysis
        
        content = f"""# Infrastructure Analysis Report

## Overview
- **Host**: {self.scan_report.host}
- **Scan ID**: {self.scan_report.scan_id}
- **Analysis Date**: {self.scan_report.timestamp[:10]}
- **Duration**: {self.scan_report.scan_duration:.2f} seconds

## Summary
- **Processes Analyzed**: {len(self.scan_report.processes)}
- **Files Discovered**: {len(self.scan_report.application_files)}
- **Architecture Pattern**: {insights.architecture_pattern}
- **Security Posture**: {insights.security_posture}

## Technology Stack
{self._format_technology_stack(insights.technology_stack)}

## Key Processes
{self._format_key_processes()}

## Application Files
{self._format_application_files()}

## Recommendations
{self._format_recommendations(insights.recommendations)}

---
*Generated by InfraDoc 2.0 - Intelligent Infrastructure Analysis*
"""
        
        file_path = self.docs_dir / "executive_summary.md"
        file_path.write_text(content, encoding='utf-8')
        logger.info(f"[DOCS] Executive summary: {file_path}")
    
    def _generate_technical_documentation(self):
        """Generate detailed technical documentation."""
        logger.info("[DOCS] Generating technical documentation")
        
        content = f"""# Technical Infrastructure Documentation

## System Overview

**Host**: {self.scan_report.host}
**Analysis Date**: {self.scan_report.timestamp}
**Scan Duration**: {self.scan_report.scan_duration:.2f} seconds

## Architecture Analysis

### Pattern
{self.scan_report.infrastructure_insights.architecture_pattern}

### Deployment Model
{self.scan_report.infrastructure_insights.deployment_model}

### Scalability Assessment
{self.scan_report.infrastructure_insights.scalability_assessment}

### Operational Complexity
{self.scan_report.infrastructure_insights.operational_complexity}

## Process Analysis

### Running Processes
{self._generate_detailed_process_table()}

### Process Classification
{self._generate_process_classification()}

## File System Analysis

### Application Files
{self._generate_detailed_file_analysis()}

### Code Dependencies
{self._generate_dependency_analysis()}

## Network and Services

### Identified Services
{self._generate_service_analysis()}

## Performance Metrics

### LLM Analysis Summary
- **Total LLM Calls**: {self.scan_report.llm_analysis_summary.get('total_llm_calls', 0)}
- **Analysis Stages**: {self.scan_report.llm_analysis_summary.get('analysis_stages', 0)}
- **Total Duration**: {self.scan_report.llm_analysis_summary.get('performance_metrics', {}).get('total_duration', 0):.2f}s
- **Average Call Duration**: {self.scan_report.llm_analysis_summary.get('performance_metrics', {}).get('avg_call_duration', 0):.2f}s

## Scan Statistics
- **Commands Executed**: {self.scan_report.scan_statistics.get('total_commands_executed', 0)}
- **Analysis Depth**: {self.scan_report.scan_statistics.get('analysis_depth', 'unknown')}
- **AI Enabled**: {self.scan_report.scan_statistics.get('ai_enabled', False)}

---
*Generated by InfraDoc 2.0 - Technical Documentation*
"""
        
        file_path = self.docs_dir / "technical_documentation.md"
        file_path.write_text(content, encoding='utf-8')
        logger.info(f"[DOCS] Technical documentation: {file_path}")
    
    def _generate_developer_guide(self):
        """Generate developer recreation guide."""
        logger.info("[DOCS] Generating developer guide")
        
        # Extract actual application files (not site-packages)
        app_files = self._filter_application_files()
        app_processes = self._filter_application_processes()
        config_files = self._identify_configuration_files()
        
        content = f"""# Developer Infrastructure Recreation Guide

## Overview

This guide provides step-by-step instructions to recreate the analyzed infrastructure environment. Use this for development, testing, or disaster recovery scenarios.

**Target System**: {self.scan_report.host}  
**Architecture**: {self.scan_report.infrastructure_insights.architecture_pattern}  
**Analysis Date**: {self.scan_report.timestamp[:10]}  

## Prerequisites

### System Requirements
- Linux-based operating system (Ubuntu 20.04+ recommended)
- Root or sudo access
- Internet connectivity for package installation

### Technology Stack Setup

Based on our analysis, install the following technologies:

{self._generate_technology_setup_instructions()}

## Step-by-Step Recreation

### 1. System Preparation

```bash
# Update system packages
sudo apt update && sudo apt upgrade -y

# Install essential development tools
sudo apt install -y build-essential curl wget git vim
```

### 2. Technology Installation

{self._generate_installation_instructions()}

### 3. Application Setup

#### Create Application Directories
```bash
{self._generate_directory_creation_commands(app_files)}
```

#### Application Files Setup

Based on the discovered application files, create the following structure:

{self._generate_application_file_structure(app_files)}

### 4. Service Configuration

#### Process Management

The following services were identified and should be configured:

{self._generate_service_configuration(app_processes)}

#### Systemd Service Configuration

{self._generate_systemd_service_files(app_processes)}

### 5. Configuration Files

{self._generate_configuration_setup(config_files)}

### 6. Networking and Security

#### Firewall Configuration
```bash
# Configure UFW firewall
sudo ufw enable
sudo ufw allow ssh
{self._generate_firewall_rules()}
```

#### SSL/TLS Setup (if web services detected)
{self._generate_ssl_setup()}

### 7. Monitoring and Logging

#### Log Configuration
```bash
# Create log directories
sudo mkdir -p /var/log/app

# Configure log rotation
sudo tee /etc/logrotate.d/app > /dev/null <<EOF
/var/log/app/*.log {{
    daily
    missingok
    rotate 30
    compress
    notifempty
    create 0644 ubuntu ubuntu
}}
EOF
```

### 8. Validation and Testing

#### Service Health Checks
```bash
{self._generate_health_check_commands()}
```

#### Application Testing
```bash
{self._generate_testing_commands()}
```

## Troubleshooting

### Common Issues

1. **Service Won't Start**
   - Check systemd service configuration
   - Verify file permissions
   - Check log files for errors

2. **Port Conflicts**
   - Use `netstat -tlnp` to check port usage
   - Modify service configurations as needed

3. **Permission Denied**
   - Verify user permissions on application directories
   - Check SELinux/AppArmor policies if applicable

### Log Locations
- Application logs: `/var/log/app/`
- System logs: `/var/log/syslog`
- Service logs: `journalctl -u service-name`

## Maintenance

### Regular Tasks
- Update system packages monthly
- Monitor disk space and log rotation
- Review security updates
- Backup application data and configurations

### Performance Monitoring
- Use `htop` for process monitoring
- Monitor disk usage with `df -h`
- Check memory usage with `free -h`

---

*Developer guide generated by InfraDoc 2.0*  
*Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""
        
        file_path = self.docs_dir / "developer_guide.md"
        file_path.write_text(content, encoding='utf-8')
        logger.info(f"[DOCS] Developer guide: {file_path}")
    
    def _generate_security_report(self):
        """Generate security analysis report."""
        logger.info("[DOCS] Generating security report")
        
        security = self.scan_report.security_analysis
        
        content = f"""# Security Analysis Report

## Executive Summary

**Infrastructure Security Assessment**
- **Host**: {self.scan_report.host}
- **Analysis Date**: {self.scan_report.timestamp[:10]}
- **Security Posture**: {self.scan_report.infrastructure_insights.security_posture}

## Security Analysis

{security.get('analysis', 'No detailed security analysis available.')}

## Key Security Findings

{self._format_security_findings(security)}

## Priority Recommendations

{self._format_security_recommendations(security)}

## Process Security Review

{self._generate_process_security_analysis()}

## Network Security Assessment

{self._generate_network_security_analysis()}

## Compliance and Governance

### Access Control
- Review user permissions and role-based access
- Implement principle of least privilege
- Regular access audits

### Data Protection
- Encrypt data in transit and at rest
- Implement proper backup strategies
- Ensure data retention policies

### Monitoring and Incident Response
- Implement comprehensive logging
- Set up security monitoring and alerting
- Develop incident response procedures

## Action Items

### Immediate (High Priority)
{self._generate_immediate_security_actions()}

### Short Term (Medium Priority)
{self._generate_short_term_security_actions()}

### Long Term (Strategic)
{self._generate_long_term_security_actions()}

---

*Security report generated by InfraDoc 2.0*  
*Assessment date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""
        
        file_path = self.docs_dir / "security_report.md"
        file_path.write_text(content, encoding='utf-8')
        logger.info(f"[DOCS] Security report: {file_path}")
    
    def _generate_architecture_documentation(self):
        """Generate architecture documentation."""
        logger.info("[DOCS] Generating architecture documentation")
        
        insights = self.scan_report.infrastructure_insights
        
        content = f"""# Architecture Documentation

## System Architecture Overview

**Architecture Pattern**: {insights.architecture_pattern}
**Deployment Model**: {insights.deployment_model}
**Host**: {self.scan_report.host}

## Component Analysis

### Core Services
{self._generate_core_services_analysis()}

### Application Components
{self._generate_application_components_analysis()}

### Infrastructure Services
{self._generate_infrastructure_services_analysis()}

## Technology Stack

### Programming Languages
{self._generate_language_analysis()}

### Frameworks and Libraries
{self._generate_framework_analysis()}

### Infrastructure Components
{self._generate_infrastructure_components()}

## Service Dependencies

{self._generate_dependency_mapping()}

## Scalability Assessment

**Current Assessment**: {insights.scalability_assessment}

### Scalability Factors
{self._generate_scalability_analysis()}

## Operational Complexity

**Current Assessment**: {insights.operational_complexity}

### Complexity Factors
{self._generate_complexity_analysis()}

## Architecture Recommendations

{self._format_architecture_recommendations(insights.recommendations)}

## Integration Points

{self._generate_integration_analysis()}

## Performance Considerations

{self._generate_performance_analysis()}

## Future Architecture Evolution

{self._generate_evolution_recommendations()}

---

*Architecture documentation generated by InfraDoc 2.0*  
*Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""
        
        file_path = self.docs_dir / "architecture_documentation.md"
        file_path.write_text(content, encoding='utf-8')
        logger.info(f"[DOCS] Architecture documentation: {file_path}")
    
    def _generate_mermaid_diagrams(self):
        """Generate Mermaid diagrams for infrastructure visualization."""
        logger.info("[DOCS] Generating Mermaid diagrams")
        
        content = f"""# Infrastructure Diagrams

## System Architecture Diagram

```mermaid
{self._generate_system_architecture_diagram()}
```

## Process Flow Diagram

```mermaid
{self._generate_process_flow_diagram()}
```

## Service Dependency Diagram

```mermaid
{self._generate_service_dependency_diagram()}
```

## Network Topology

```mermaid
{self._generate_network_topology_diagram()}
```

## Deployment Architecture

```mermaid
{self._generate_deployment_diagram()}
```

---

*Diagrams generated by InfraDoc 2.0*  
*Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""
        
        file_path = self.docs_dir / "infrastructure_diagrams.md"
        file_path.write_text(content, encoding='utf-8')
        logger.info(f"[DOCS] Mermaid diagrams: {file_path}")
    
    def _generate_documentation_index(self):
        """Generate documentation index/README."""
        logger.info("[DOCS] Generating documentation index")
        
        content = f"""# Infrastructure Documentation

## Overview

This documentation suite provides comprehensive analysis and guidance for the infrastructure at `{self.scan_report.host}`.

**Analysis Date**: {self.scan_report.timestamp[:10]}  
**Scan ID**: {self.scan_report.scan_id}  
**Duration**: {self.scan_report.scan_duration:.2f} seconds

## Documentation Structure

### 📊 Executive Summary
**File**: [executive_summary.md](./executive_summary.md)  
High-level overview of infrastructure analysis, key findings, and strategic recommendations.

### 🔧 Technical Documentation
**File**: [technical_documentation.md](./technical_documentation.md)  
Detailed technical analysis including processes, files, and system configuration.

### 👨‍💻 Developer Guide
**File**: [developer_guide.md](./developer_guide.md)  
Step-by-step guide to recreate the infrastructure environment for development and testing.

### 🔒 Security Report
**File**: [security_report.md](./security_report.md)  
Comprehensive security analysis with vulnerabilities, risks, and remediation recommendations.

### 🏗️ Architecture Documentation
**File**: [architecture_documentation.md](./architecture_documentation.md)  
Detailed architecture analysis including patterns, components, and design decisions.

### 📊 Infrastructure Diagrams
**File**: [infrastructure_diagrams.md](./infrastructure_diagrams.md)  
Visual representations of system architecture, process flows, and dependencies.

## Key Findings

### System Summary
- **Processes Analyzed**: {len(self.scan_report.processes)}
- **Application Files**: {len(self.scan_report.application_files)}
- **Architecture Pattern**: {self.scan_report.infrastructure_insights.architecture_pattern}
- **Security Posture**: {self.scan_report.infrastructure_insights.security_posture}

### Technology Stack
{self._format_technology_stack(self.scan_report.infrastructure_insights.technology_stack)}

### Critical Services
{self._format_critical_services()}

## Quick Start

1. **For Executives**: Start with [Executive Summary](./executive_summary.md)
2. **For Developers**: Review [Developer Guide](./developer_guide.md)
3. **For Security Teams**: Check [Security Report](./security_report.md)
4. **For Architects**: Study [Architecture Documentation](./architecture_documentation.md)

## Analysis Methodology

This documentation was generated using InfraDoc 2.0's AI-powered analysis:

- **LLM Calls**: {self.scan_report.llm_analysis_summary.get('total_llm_calls', 0)}
- **Analysis Stages**: {self.scan_report.llm_analysis_summary.get('analysis_stages', 0)}
- **AI Confidence**: {int(self.scan_report.llm_analysis_summary.get('overall_confidence', 0) * 100)}%

## Support and Updates

For questions about this documentation or to request updates:
- Re-run InfraDoc analysis for latest state
- Review change logs for infrastructure modifications
- Validate configurations against security baselines

---

*Documentation generated by InfraDoc 2.0 - Intelligent Infrastructure Analysis*  
*Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""
        
        file_path = self.docs_dir / "README.md"
        file_path.write_text(content, encoding='utf-8')
        logger.info(f"[DOCS] Documentation index: {file_path}")
    
    # Helper methods for formatting content
    
    def _filter_application_files(self) -> List[Dict]:
        """Filter out virtual environment and site-packages files."""
        app_files = []
        for file_info in self.scan_report.application_files:
            path = file_info.path
            # Skip virtual environment and site-packages files
            if not any(skip in path for skip in ['/site-packages/', '/venv/lib/', '/venv/bin/', '__pycache__']):
                # Focus on actual application files
                if any(app_pattern in path for app_pattern in ['/opt/', '/srv/', '/var/www/', '/home/', '/app']):
                    if not path.endswith(('.pyc', '.pyo')):
                        app_files.append(asdict(file_info))
        return app_files
    
    def _filter_application_processes(self) -> List[Dict]:
        """Filter for actual application processes."""
        app_processes = []
        for process in self.scan_report.processes:
            # Focus on application workers and services
            if any(pattern in process.command.lower() for pattern in ['worker', 'app', 'service']):
                if not any(system_pattern in process.command.lower() for system_pattern in ['systemd', 'kernel', 'dbus']):
                    app_processes.append(asdict(process))
        return app_processes
    
    def _identify_configuration_files(self) -> List[str]:
        """Identify potential configuration files."""
        config_files = []
        # Common configuration file locations
        common_configs = [
            '/etc/systemd/system/*.service',
            '/etc/nginx/nginx.conf',
            '/etc/nginx/sites-available/*',
            '/opt/*/config/*',
            '/srv/*/config/*',
            '/var/www/*/config/*'
        ]
        return common_configs
    
    def _format_technology_stack(self, tech_stack: List[str]) -> str:
        """Format technology stack list."""
        if not tech_stack:
            return "- Technology stack analysis pending"
        return "\n".join(f"- {tech}" for tech in tech_stack)
    
    def _format_key_processes(self) -> str:
        """Format key processes summary."""
        processes = []
        for process in self.scan_report.processes[:10]:  # Top 10 processes
            processes.append(f"- **PID {process.pid}**: {process.name} ({process.service_classification})")
        return "\n".join(processes)
    
    def _format_application_files(self) -> str:
        """Format application files summary."""
        file_types = {}
        for file_info in self.scan_report.application_files:
            lang = file_info.language
            file_types[lang] = file_types.get(lang, 0) + 1
        
        return "\n".join(f"- **{lang}**: {count} files" for lang, count in file_types.items())
    
    def _format_recommendations(self, recommendations: List[str]) -> str:
        """Format recommendations list."""
        if not recommendations:
            return "- No specific recommendations available"
        return "\n".join(f"- {rec}" for rec in recommendations)
    
    def _generate_detailed_process_table(self) -> str:
        """Generate detailed process analysis table."""
        table = "| PID | Process | User | Classification | Purpose |\n"
        table += "|-----|---------|------|----------------|----------|\n"
        
        for process in self.scan_report.processes:
            table += f"| {process.pid} | {process.name} | {process.user} | {process.service_classification} | {process.service_purpose} |\n"
        
        return table
    
    def _generate_process_classification(self) -> str:
        """Generate process classification summary."""
        classifications = {}
        for process in self.scan_report.processes:
            cls = process.service_classification
            classifications[cls] = classifications.get(cls, 0) + 1
        
        return "\n".join(f"- **{cls}**: {count} processes" for cls, count in classifications.items())
    
    def _generate_detailed_file_analysis(self) -> str:
        """Generate detailed file analysis."""
        analysis = []
        for file_info in self.scan_report.application_files:
            analysis.append(f"""
**{file_info.path}**
- Language: {file_info.language}
- Size: {file_info.size} bytes
- Modified: {file_info.last_modified}
- Functions: {len(file_info.functions) if file_info.functions else 0}
- Classes: {len(file_info.classes) if file_info.classes else 0}
""")
        return "\n".join(analysis)
    
    def _generate_dependency_analysis(self) -> str:
        """Generate dependency analysis."""
        all_imports = set()
        for file_info in self.scan_report.application_files:
            if file_info.imports:
                all_imports.update(file_info.imports)
        
        return f"Total unique imports/dependencies: {len(all_imports)}"
    
    def _generate_service_analysis(self) -> str:
        """Generate service analysis."""
        services = []
        for process in self.scan_report.processes:
            if process.service_classification in ['web_server', 'service', 'background_worker']:
                services.append(f"- {process.name} ({process.service_classification})")
        return "\n".join(services)
    
    def _generate_technology_setup_instructions(self) -> str:
        """Generate technology setup instructions."""
        instructions = []
        
        # Detect technologies from processes
        has_python = any('python' in p.command.lower() for p in self.scan_report.processes)
        has_nginx = any('nginx' in p.command.lower() for p in self.scan_report.processes)
        
        if has_python:
            instructions.append("- Python 3.x runtime and virtual environment")
        if has_nginx:
            instructions.append("- Nginx web server")
        
        return "\n".join(instructions) if instructions else "- Basic Linux utilities"
    
    def _generate_installation_instructions(self) -> str:
        """Generate installation instructions."""
        instructions = ["```bash"]
        
        # Detect and add installation commands
        has_python = any('python' in p.command.lower() for p in self.scan_report.processes)
        has_nginx = any('nginx' in p.command.lower() for p in self.scan_report.processes)
        
        if has_python:
            instructions.extend([
                "# Install Python and virtual environment",
                "sudo apt install -y python3 python3-pip python3-venv",
                ""
            ])
        
        if has_nginx:
            instructions.extend([
                "# Install Nginx",
                "sudo apt install -y nginx",
                "sudo systemctl enable nginx",
                ""
            ])
        
        instructions.append("```")
        return "\n".join(instructions)
    
    def _generate_directory_creation_commands(self, app_files: List[Dict]) -> str:
        """Generate directory creation commands for actual application files."""
        directories = set()
        
        for file_info in app_files:
            path = Path(file_info['path'])
            # Only include actual application directories
            if not any(skip in str(path) for skip in ['/site-packages/', '/venv/', '__pycache__']):
                directories.add(str(path.parent))
        
        commands = []
        for directory in sorted(directories):
            commands.append(f"sudo mkdir -p {directory}")
        
        return "\n".join(commands) if commands else "# No application directories detected"
    
    def _generate_application_file_structure(self, app_files: List[Dict]) -> str:
        """Generate application file structure description."""
        if not app_files:
            return "No application files detected outside of virtual environments."
        
        structure = []
        for file_info in app_files:
            structure.append(f"- `{file_info['path']}` ({file_info['language']})")
        
        return "\n".join(structure)
    
    def _generate_service_configuration(self, app_processes: List[Dict]) -> str:
        """Generate service configuration for application processes."""
        if not app_processes:
            return "No application processes requiring service configuration detected."
        
        configs = []
        for process in app_processes:
            configs.append(f"""
**{process['name']}** ({process['service_classification']})
- Purpose: {process['service_purpose']}
- User: {process['user']}
- Command: `{process['command']}`
""")
        
        return "\n".join(configs)
    
    def _generate_systemd_service_files(self, app_processes: List[Dict]) -> str:
        """Generate systemd service file examples."""
        if not app_processes:
            return "No application processes requiring systemd configuration."
        
        service_files = []
        
        for process in app_processes:
            if 'worker' in process['command'].lower() or process['service_classification'] == 'background_worker':
                service_name = process['name'].replace('/', '').replace(' ', '-')
                working_dir = process.get('working_dir', '/opt/app')
                
                service_files.append(f"""
Create systemd service file for {process['name']}:

```bash
sudo tee /etc/systemd/system/{service_name}.service > /dev/null <<EOF
[Unit]
Description={process['service_purpose']}
After=network.target

[Service]
Type=simple
User={process['user']}
WorkingDirectory={working_dir}
ExecStart={process['command']}
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

# Enable and start the service
sudo systemctl daemon-reload
sudo systemctl enable {service_name}.service
sudo systemctl start {service_name}.service
```
""")
        
        return "\n".join(service_files)
    
    def _generate_configuration_setup(self, config_files: List[str]) -> str:
        """Generate configuration file setup instructions."""
        return f"""
Create necessary configuration files based on discovered patterns:

{chr(10).join(f'- {config}' for config in config_files)}

**Note**: Review existing configuration files on the target system and adapt accordingly.
"""
    
    def _generate_firewall_rules(self) -> str:
        """Generate firewall rules based on detected services."""
        rules = []
        
        # Check for web services
        has_web = any('nginx' in p.command.lower() for p in self.scan_report.processes)
        if has_web:
            rules.extend(["sudo ufw allow 80", "sudo ufw allow 443"])
        
        return "\n".join(rules) if rules else "# No additional ports detected"
    
    def _generate_ssl_setup(self) -> str:
        """Generate SSL setup instructions."""
        has_web = any('nginx' in p.command.lower() for p in self.scan_report.processes)
        
        if has_web:
            return """```bash
# Install Certbot for Let's Encrypt
sudo apt install -y certbot python3-certbot-nginx

# Obtain SSL certificate (replace with your domain)
sudo certbot --nginx -d your-domain.com
```"""
        
        return "No web services detected requiring SSL configuration."
    
    def _generate_health_check_commands(self) -> str:
        """Generate health check commands."""
        commands = ["# Check service status"]
        
        # Add service checks based on detected processes
        for process in self.scan_report.processes:
            if process.service_classification in ['web_server', 'service']:
                if 'nginx' in process.command.lower():
                    commands.append("sudo systemctl status nginx")
                elif process.service_classification == 'service':
                    service_name = process.name.replace('/', '').replace(' ', '-')
                    commands.append(f"sudo systemctl status {service_name}")
        
        commands.extend([
            "",
            "# Check application processes",
            "ps aux | grep python",
            "ps aux | grep worker",
            "",
            "# Check network connections",
            "sudo netstat -tlnp"
        ])
        
        return "\n".join(commands)
    
    def _generate_testing_commands(self) -> str:
        """Generate testing commands."""
        commands = []
        
        # Web service testing
        has_web = any('nginx' in p.command.lower() for p in self.scan_report.processes)
        if has_web:
            commands.extend([
                "# Test web services",
                "curl -I http://localhost",
                ""
            ])
        
        commands.extend([
            "# Check application logs",
            "tail -f /var/log/app/application.log",
            "",
            "# Monitor system resources",
            "htop"
        ])
        
        return "\n".join(commands)
    
    def _format_security_findings(self, security: Dict) -> str:
        """Format security findings."""
        findings = security.get('key_findings', [])
        if not findings:
            return "- No specific security findings documented"
        return "\n".join(f"- {finding}" for finding in findings)
    
    def _format_security_recommendations(self, security: Dict) -> str:
        """Format security recommendations."""
        recommendations = security.get('recommendations', [])
        if not recommendations:
            return "- Review and implement security best practices"
        return "\n".join(f"- {rec}" for rec in recommendations[:10])  # Top 10
    
    def _generate_process_security_analysis(self) -> str:
        """Generate process-level security analysis."""
        root_processes = [p for p in self.scan_report.processes if p.user == 'root']
        
        analysis = f"""
### Processes Running as Root
{len(root_processes)} processes are running with root privileges:

{chr(10).join(f'- PID {p.pid}: {p.name}' for p in root_processes[:5])}

**Risk Level**: High - Consider running with least privileges
"""
        return analysis
    
    def _generate_network_security_analysis(self) -> str:
        """Generate network security analysis."""
        return """
### Network Services
- Review open ports and listening services
- Ensure firewall is properly configured
- Implement network segmentation where appropriate
- Monitor network traffic for anomalies
"""
    
    def _generate_immediate_security_actions(self) -> str:
        """Generate immediate security actions."""
        actions = []
        
        # Check for root processes
        root_processes = [p for p in self.scan_report.processes if p.user == 'root']
        if root_processes:
            actions.append("- Review and minimize processes running as root")
        
        actions.extend([
            "- Update all system packages",
            "- Review and harden SSH configuration",
            "- Implement proper firewall rules"
        ])
        
        return "\n".join(actions)
    
    def _generate_short_term_security_actions(self) -> str:
        """Generate short-term security actions."""
        return """- Implement comprehensive logging and monitoring
- Set up automated security updates
- Conduct security configuration review
- Implement backup and disaster recovery procedures"""
    
    def _generate_long_term_security_actions(self) -> str:
        """Generate long-term security actions."""
        return """- Implement infrastructure as code
- Consider containerization for better isolation
- Develop security training programs
- Regular penetration testing and security audits"""
    
    def _generate_core_services_analysis(self) -> str:
        """Generate core services analysis."""
        core_services = []
        for process in self.scan_report.processes:
            if process.service_classification in ['web_server', 'service']:
                core_services.append(f"- {process.name}: {process.service_purpose}")
        
        return "\n".join(core_services) if core_services else "- No core services identified"
    
    def _generate_application_components_analysis(self) -> str:
        """Generate application components analysis."""
        app_components = []
        for process in self.scan_report.processes:
            if process.service_classification in ['application', 'background_worker']:
                app_components.append(f"- {process.name}: {process.service_purpose}")
        
        return "\n".join(app_components) if app_components else "- No application components identified"
    
    def _generate_infrastructure_services_analysis(self) -> str:
        """Generate infrastructure services analysis."""
        infra_services = []
        for process in self.scan_report.processes:
            if any(service in process.name.lower() for service in ['systemd', 'dbus', 'chrony', 'rsyslog']):
                infra_services.append(f"- {process.name}: System service")
        
        return "\n".join(infra_services) if infra_services else "- Standard Linux infrastructure services"
    
    def _generate_language_analysis(self) -> str:
        """Generate programming language analysis."""
        languages = {}
        for file_info in self.scan_report.application_files:
            lang = file_info.language
            languages[lang] = languages.get(lang, 0) + 1
        
        return "\n".join(f"- {lang}: {count} files" for lang, count in languages.items())
    
    def _generate_framework_analysis(self) -> str:
        """Generate framework analysis."""
        frameworks = set()
        for file_info in self.scan_report.application_files:
            if file_info.imports:
                for imp in file_info.imports:
                    if any(framework in imp.lower() for framework in ['django', 'flask', 'fastapi', 'express']):
                        frameworks.add(imp)
        
        return "\n".join(f"- {framework}" for framework in frameworks) if frameworks else "- Framework analysis pending"
    
    def _generate_infrastructure_components(self) -> str:
        """Generate infrastructure components list."""
        components = []
        
        # Detect web server
        if any('nginx' in p.command.lower() for p in self.scan_report.processes):
            components.append("- Nginx web server")
        
        # Detect time sync
        if any('chrony' in p.command.lower() for p in self.scan_report.processes):
            components.append("- Chrony time synchronization")
        
        # Detect logging
        if any('rsyslog' in p.command.lower() for p in self.scan_report.processes):
            components.append("- Rsyslog system logging")
        
        return "\n".join(components) if components else "- Standard Linux infrastructure"
    
    def _generate_dependency_mapping(self) -> str:
        """Generate service dependency mapping."""
        return """
### Service Dependencies

Based on process analysis:
- Web services depend on application workers
- Application workers may depend on external services
- All services depend on system infrastructure (logging, time sync)

**Recommendation**: Map detailed dependencies for better understanding.
"""
    
    def _generate_scalability_analysis(self) -> str:
        """Generate scalability analysis."""
        worker_count = len([p for p in self.scan_report.processes if 'worker' in p.command.lower()])
        
        return f"""
- **Current Workers**: {worker_count} background worker processes detected
- **Horizontal Scaling**: Consider load balancing for web services
- **Vertical Scaling**: Monitor resource usage for capacity planning
- **Bottlenecks**: Identify and address performance bottlenecks
"""
    
    def _generate_complexity_analysis(self) -> str:
        """Generate complexity analysis."""
        total_processes = len(self.scan_report.processes)
        app_processes = len([p for p in self.scan_report.processes if p.service_classification in ['application', 'background_worker']])
        
        return f"""
- **Total Processes**: {total_processes}
- **Application Processes**: {app_processes}
- **Complexity Drivers**: Multiple services, background workers
- **Management**: Consider orchestration tools for complex deployments
"""
    
    def _format_architecture_recommendations(self, recommendations: List[str]) -> str:
        """Format architecture recommendations."""
        arch_recommendations = [rec for rec in recommendations if any(keyword in rec.lower() for keyword in ['architecture', 'scalability', 'containerization', 'orchestration'])]
        
        return "\n".join(f"- {rec}" for rec in arch_recommendations[:5]) if arch_recommendations else "- Review current architecture for optimization opportunities"
    
    def _generate_integration_analysis(self) -> str:
        """Generate integration analysis."""
        integrations = []
        for process in self.scan_report.processes:
            if process.integrations_detected:
                integrations.extend(process.integrations_detected)
        
        return "\n".join(f"- {integration}" for integration in set(integrations)) if integrations else "- No external integrations detected"
    
    def _generate_performance_analysis(self) -> str:
        """Generate performance analysis."""
        return f"""
### Current Performance Metrics
- **Analysis Duration**: {self.scan_report.scan_duration:.2f} seconds
- **Commands Executed**: {self.scan_report.scan_statistics.get('total_commands_executed', 0)}
- **LLM Processing**: {self.scan_report.llm_analysis_summary.get('total_llm_calls', 0)} calls

### Performance Recommendations
- Implement application performance monitoring
- Set up resource usage alerts
- Regular performance profiling and optimization
"""
    
    def _generate_evolution_recommendations(self) -> str:
        """Generate evolution recommendations."""
        return """
### Short-term Evolution (3-6 months)
- Implement containerization for key services
- Set up automated deployment pipelines
- Enhance monitoring and alerting

### Long-term Evolution (6-12 months)
- Consider microservices architecture optimization
- Implement infrastructure as code
- Evaluate cloud-native solutions

### Strategic Evolution (1+ years)
- Full cloud migration assessment
- Advanced orchestration with Kubernetes
- Implementation of service mesh for complex communications
"""
    
    def _generate_system_architecture_diagram(self) -> str:
        """Generate system architecture Mermaid diagram."""
        return """graph TB
    subgraph "Web Layer"
        WS[Web Server<br/>Nginx]
    end
    
    subgraph "Application Layer"
        APP1[Application Worker 1]
        APP2[Application Worker 2]
    end
    
    subgraph "System Services"
        LOG[Logging<br/>Rsyslog]
        TIME[Time Sync<br/>Chrony]
        POLICY[Policy Kit]
    end
    
    WS --> APP1
    WS --> APP2
    APP1 --> LOG
    APP2 --> LOG
    APP1 --> TIME
    APP2 --> TIME
"""
    
    def _generate_process_flow_diagram(self) -> str:
        """Generate process flow Mermaid diagram."""
        return """flowchart TD
    START[System Boot] --> INIT[Init System]
    INIT --> INFRA[Infrastructure Services]
    INFRA --> WEB[Web Services]
    INFRA --> APPS[Application Services]
    WEB --> WORKERS[Background Workers]
    APPS --> WORKERS
    WORKERS --> PROCESSING[Task Processing]
"""
    
    def _generate_service_dependency_diagram(self) -> str:
        """Generate service dependency Mermaid diagram."""
        return """graph LR
    subgraph "External"
        EXT[External Services]
    end
    
    subgraph "Infrastructure"
        NET[Network]
        FS[File System]
        LOG[Logging]
    end
    
    subgraph "Applications"
        WEB[Web Server]
        WORKER1[Worker 1]
        WORKER2[Worker 2]
    end
    
    EXT --> WEB
    WEB --> WORKER1
    WEB --> WORKER2
    WORKER1 --> LOG
    WORKER2 --> LOG
    WEB --> NET
    WORKER1 --> FS
    WORKER2 --> FS
"""
    
    def _generate_network_topology_diagram(self) -> str:
        """Generate network topology Mermaid diagram."""
        return """graph TB
    INTERNET[Internet] --> LB[Load Balancer]
    LB --> WEB[Web Server<br/>Port 80/443]
    WEB --> APP[Application Layer]
    APP --> WORKER[Worker Processes]
    
    subgraph "Security"
        FW[Firewall]
        SSL[SSL/TLS]
    end
    
    INTERNET --> FW
    FW --> SSL
    SSL --> LB
"""
    
    def _generate_deployment_diagram(self) -> str:
        """Generate deployment Mermaid diagram."""
        return """graph TB
    subgraph "EC2 Instance"
        subgraph "System Layer"
            OS[Ubuntu Linux]
            SYSTEMD[Systemd Services]
        end
        
        subgraph "Runtime Layer"
            PYTHON[Python Runtime]
            NGINX[Nginx]
        end
        
        subgraph "Application Layer"
            WORKERS[Python Workers]
            CONFIG[Configuration Files]
        end
    end
    
    subgraph "External Dependencies"
        SQS[AWS SQS]
        S3[AWS S3]
    end
    
    WORKERS --> SQS
    WORKERS --> S3
    NGINX --> WORKERS
    SYSTEMD --> WORKERS
    PYTHON --> WORKERS
"""
    
    def _format_critical_services(self) -> str:
        """Format critical services summary."""
        critical_services = []
        for process in self.scan_report.processes:
            if process.service_classification in ['web_server', 'background_worker'] or 'worker' in process.command.lower():
                critical_services.append(f"- {process.name} ({process.service_classification})")
        
        return "\n".join(critical_services[:5]) if critical_services else "- No critical services identified"